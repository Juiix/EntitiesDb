<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ include file="Generics.ttinclude" #>
namespace EntitiesDb;

<#
	for (int indexC = 1; indexC <= GenericMixedCount - 1; indexC++)
	{
		var genericsC = FormatComma(indexC, "T{0}");
		var getsC = FormatLine(indexC, "public ref T{0}? GetT{0}(int index) => ref _chunk.Get(index, _offsets.T{0});");
		var getsReadOnlyC = FormatLine(indexC, "public ref readonly T{0}? GetReadOnlyT{0}(int index) => ref _chunk.GetReadOnly(index, _offsets.T{0});");
		var handlesC = FormatLine(indexC, "public Handle<T{0}?> GetHandleT{0}() => _chunk.GetHandle(_offsets.T{0});");
		var handlesReadOnlyC = FormatLine(indexC, "public ReadOnlyHandle<T{0}?> GetHandleReadOnlyT{0}() => _chunk.GetHandleReadOnly(_offsets.T{0});");
		var outsC = FormatComma(indexC, "out Handle<T{0}?> t{0}Handle");
		var outSetsC = FormatLine(indexC, "t{0}Handle = _chunk.GetHandle(_offsets.T{0});");
		
		for (int indexB = 1; indexC + indexB <= GenericMixedCount; indexB++)
		{
			var genericsB = Generics(indexB, indexC);
			var constraints = FormatLine(indexB, "where T{0} : unmanaged", indexC);
			var getsB = FormatLine(indexB, "public DynamicBuffer<T{0}> GetBufferT{0}(int index) => _chunk.GetBuffer(index, _offsets.T{0});", indexC);
			var getsReadOnlyB = FormatLine(indexB, "public ReadOnlyBuffer<T{0}> GetBufferReadOnlyT{0}(int index) => _chunk.GetBufferReadOnly(index, _offsets.T{0});", indexC);
			var handlesB = FormatLine(indexB, "public DynamicBufferHandle<T{0}> GetBufferHandleT{0}() => _chunk.GetBufferHandle(_offsets.T{0});", indexC);
			var handlesReadOnlyB = FormatLine(indexB, "public ReadOnlyBufferHandle<T{0}> GetBufferHandleReadOnlyT{0}() => _chunk.GetBufferHandleReadOnly(_offsets.T{0});", indexC);
			var outsB = FormatComma(indexB, "out DynamicBufferHandle<T{0}> t{0}Handle", indexC);
			var outSetsB = FormatLine(indexB, "t{0}Handle = _chunk.GetBufferHandle(_offsets.T{0});", indexC);
#>
public readonly ref struct ChunkMixed<#= indexC #><<#= genericsC #>, <#= genericsB #>>(ref readonly Chunk chunk, Offsets<<#= genericsC #>, <#= genericsB #>> offsets)
	<#= Indent(constraints, 4) #>
{
#if NETSTANDARD2_1
	private readonly ReadOnlyRef<Chunk> _chunkRef = new ReadOnlyRef<Chunk>(in chunk);
	private readonly ref readonly Chunk _chunk => ref _chunkRef.Value;
#else
	private readonly ref readonly Chunk _chunk = ref chunk;
#endif
	private readonly Offsets<<#= genericsC #>, <#= genericsB #>> _offsets = offsets;

	public int EntityCount => _chunk.EntityCount;
	
	public ReadOnlyHandle<Entity> GetEntityHandle() => _chunk.GetEntityHandle();
	<#= Indent(getsC, 4) #>
	<#= Indent(getsB, 4) #>
	<#= Indent(getsReadOnlyC, 4) #>
	<#= Indent(getsReadOnlyB, 4) #>
	<#= Indent(handlesC, 4) #>
	<#= Indent(handlesB, 4) #>
	<#= Indent(handlesReadOnlyC, 4) #>
	<#= Indent(handlesReadOnlyB, 4) #>

	public void Deconstruct(out int length, out ReadOnlyHandle<Entity> entities, <#= outsC #>, <#= outsB #>)
	{
		length = _chunk.EntityCount;
		entities = _chunk.GetEntityHandle();
		<#= Indent(outSetsC, 8) #>
		<#= Indent(outSetsB, 8) #>
	}

	public void Deconstruct(out int length, <#= outsC #>, <#= outsB #>)
	{
		length = _chunk.EntityCount;
		<#= Indent(outSetsC, 8) #>
		<#= Indent(outSetsB, 8) #>
	}
}
<#
		}
	}
#>